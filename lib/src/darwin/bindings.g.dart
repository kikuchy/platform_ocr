// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void CFRelease(ffi.Pointer<ffi.Void> cf);

@ffi.Native<objc.CGRect Function(objc.CGRect, ffi.Size, ffi.Size)>()
external objc.CGRect VNImageRectForNormalizedRect(
  objc.CGRect normalizedRect,
  int imageWidth,
  int imageHeight,
);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external int _NativeLibrary_protocolTrampoline_1ckyi24(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_r1s65y(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_r1s65y(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_protocolTrampoline_zb0vvk(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1l4hxwm(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_f167m6(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_f167m6(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_1l4hxwm(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
extension type NSUUID._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUUID',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
  }

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUUID',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
  }
}

final class CGImage extends ffi.Opaque {}

/// WARNING: VNRequestRevisionProviding is a stub. To generate bindings for this class, include
/// VNRequestRevisionProviding in your config's objc-protocols list.
///
/// VNRequestRevisionProviding
extension type VNRequestRevisionProviding._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [VNRequestRevisionProviding] that points to the same underlying object as [other].
  VNRequestRevisionProviding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [VNRequestRevisionProviding] that wraps the given raw object pointer.
  VNRequestRevisionProviding.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
    1 => kCGImagePropertyOrientationUp,
    2 => kCGImagePropertyOrientationUpMirrored,
    3 => kCGImagePropertyOrientationDown,
    4 => kCGImagePropertyOrientationDownMirrored,
    5 => kCGImagePropertyOrientationLeftMirrored,
    6 => kCGImagePropertyOrientationRight,
    7 => kCGImagePropertyOrientationRightMirrored,
    8 => kCGImagePropertyOrientationLeft,
    _ => throw ArgumentError(
      'Unknown value for CGImagePropertyOrientation: $value',
    ),
  };
}

final class __CVBuffer extends ffi.Opaque {}

/// WARNING: MLComputeDeviceProtocol is a stub. To generate bindings for this class, include
/// MLComputeDeviceProtocol in your config's objc-protocols list.
///
/// MLComputeDeviceProtocol
extension type MLComputeDeviceProtocol._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [MLComputeDeviceProtocol] that points to the same underlying object as [other].
  MLComputeDeviceProtocol.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [MLComputeDeviceProtocol] that wraps the given raw object pointer.
  MLComputeDeviceProtocol.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class CMTimeFlags {
  static const kCMTimeFlags_Valid = 1;
  static const kCMTimeFlags_HasBeenRounded = 2;
  static const kCMTimeFlags_PositiveInfinity = 4;
  static const kCMTimeFlags_NegativeInfinity = 8;
  static const kCMTimeFlags_Indefinite = 16;
  static const kCMTimeFlags_ImpliedValueFlagsMask = 28;
}

@ffi.Packed(4)
final class CMTime extends ffi.Struct {
  @ffi.Int64()
  external int value;

  @ffi.Int32()
  external int timescale;

  @ffi.Uint32()
  external int flags;

  @ffi.Int64()
  external int epoch;
}

final class CMTimeRange extends ffi.Struct {
  external CMTime start;

  external CMTime duration;
}

final class opaqueCMSampleBuffer extends ffi.Opaque {}

late final _class_VNObservation = objc.getClass("VNObservation");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_uuid = objc.registerName("uuid");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_confidence = objc.registerName("confidence");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_timeRange = objc.registerName("timeRange");
final _objc_msgSend_rynxlp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CMTimeRange Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CMTimeRange Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_rynxlpStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CMTimeRange>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CMTimeRange>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_requestRevision = objc.registerName("requestRevision");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

/// VNObservation
extension type VNObservation._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding,
        VNRequestRevisionProviding {
  /// Constructs a [VNObservation] that points to the same underlying object as [other].
  VNObservation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNObservation] that wraps the given raw object pointer.
  VNObservation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNObservation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNObservation,
  );

  /// alloc
  static VNObservation alloc() {
    final $ret = _objc_msgSend_151sglz(_class_VNObservation, _sel_alloc);
    return VNObservation.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static VNObservation allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNObservation,
      _sel_allocWithZone_,
      zone,
    );
    return VNObservation.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static VNObservation new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNObservation, _sel_new);
    return VNObservation.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_VNObservation,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of VNObservation constructed with the default `new` method.
  VNObservation() : this.as(new$().object$);
}

extension VNObservation$Methods on VNObservation {
  /// confidence
  double get confidence {
    objc.checkOsVersionInternal(
      'VNObservation.confidence',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_confidence)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_confidence);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  VNObservation init() {
    objc.checkOsVersionInternal(
      'VNObservation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNObservation.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  VNObservation? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : VNObservation.fromPointer($ret, retain: false, release: true);
  }

  /// requestRevision
  int get requestRevision {
    objc.checkOsVersionInternal(
      'VNObservation.requestRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_requestRevision);
  }

  /// timeRange
  CMTimeRange get timeRange {
    objc.checkOsVersionInternal(
      'VNObservation.timeRange',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<CMTimeRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_rynxlpStret($ptr, object$.ref.pointer, _sel_timeRange)
        : $ptr.ref = _objc_msgSend_rynxlp(object$.ref.pointer, _sel_timeRange);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CMTimeRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CMTimeRange>($finalizable);
  }

  /// uuid
  NSUUID get uuid {
    objc.checkOsVersionInternal(
      'VNObservation.uuid',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_uuid);
    return NSUUID.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_VNDetectedObjectObservation = objc.getClass(
  "VNDetectedObjectObservation",
);
late final _sel_observationWithBoundingBox_ = objc.registerName(
  "observationWithBoundingBox:",
);
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_observationWithRequestRevision_boundingBox_ = objc.registerName(
  "observationWithRequestRevision:boundingBox:",
);
final _objc_msgSend_1hw0xz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        objc.CGRect,
      )
    >();
late final _sel_boundingBox = objc.registerName("boundingBox");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// WARNING: VNPixelBufferObservation is a stub. To generate bindings for this class, include
/// VNPixelBufferObservation in your config's objc-interfaces list.
///
/// VNPixelBufferObservation
extension type VNPixelBufferObservation._(objc.ObjCObject object$)
    implements objc.ObjCObject, VNObservation {
  /// Constructs a [VNPixelBufferObservation] that points to the same underlying object as [other].
  VNPixelBufferObservation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNPixelBufferObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }

  /// Constructs a [VNPixelBufferObservation] that wraps the given raw object pointer.
  VNPixelBufferObservation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNPixelBufferObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }
}

late final _sel_globalSegmentationMask = objc.registerName(
  "globalSegmentationMask",
);

/// VNDetectedObjectObservation
extension type VNDetectedObjectObservation._(objc.ObjCObject object$)
    implements objc.ObjCObject, VNObservation {
  /// Constructs a [VNDetectedObjectObservation] that points to the same underlying object as [other].
  VNDetectedObjectObservation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNDetectedObjectObservation] that wraps the given raw object pointer.
  VNDetectedObjectObservation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNDetectedObjectObservation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNDetectedObjectObservation,
  );

  /// alloc
  static VNDetectedObjectObservation alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNDetectedObjectObservation,
      _sel_alloc,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static VNDetectedObjectObservation allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNDetectedObjectObservation,
      _sel_allocWithZone_,
      zone,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static VNDetectedObjectObservation new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNDetectedObjectObservation,
      _sel_new,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// observationWithBoundingBox:
  static VNDetectedObjectObservation observationWithBoundingBox(
    objc.CGRect boundingBox,
  ) {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation.observationWithBoundingBox:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      _class_VNDetectedObjectObservation,
      _sel_observationWithBoundingBox_,
      boundingBox,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// observationWithRequestRevision:boundingBox:
  static VNDetectedObjectObservation observationWithRequestRevision(
    int requestRevision, {
    required objc.CGRect boundingBox,
  }) {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation.observationWithRequestRevision:boundingBox:',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_1hw0xz7(
      _class_VNDetectedObjectObservation,
      _sel_observationWithRequestRevision_boundingBox_,
      requestRevision,
      boundingBox,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_VNDetectedObjectObservation,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of VNDetectedObjectObservation constructed with the default `new` method.
  VNDetectedObjectObservation() : this.as(new$().object$);
}

extension VNDetectedObjectObservation$Methods on VNDetectedObjectObservation {
  /// boundingBox
  objc.CGRect get boundingBox {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation.boundingBox',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_boundingBox)
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_boundingBox,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// globalSegmentationMask
  VNPixelBufferObservation? get globalSegmentationMask {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation.globalSegmentationMask',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_globalSegmentationMask,
    );
    return $ret.address == 0
        ? null
        : VNPixelBufferObservation.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// init
  VNDetectedObjectObservation init() {
    objc.checkOsVersionInternal(
      'VNDetectedObjectObservation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNDetectedObjectObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  VNDetectedObjectObservation? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : VNDetectedObjectObservation.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }
}

late final _class_VNRectangleObservation = objc.getClass(
  "VNRectangleObservation",
);
late final _sel_rectangleObservationWithRequestRevision_topLeft_bottomLeft_bottomRight_topRight_ =
    objc.registerName(
      "rectangleObservationWithRequestRevision:topLeft:bottomLeft:bottomRight:topRight:",
    );
final _objc_msgSend_22ka0q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          objc.CGPoint,
          objc.CGPoint,
          objc.CGPoint,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        objc.CGPoint,
        objc.CGPoint,
        objc.CGPoint,
        objc.CGPoint,
      )
    >();
late final _sel_rectangleObservationWithRequestRevision_topLeft_topRight_bottomRight_bottomLeft_ =
    objc.registerName(
      "rectangleObservationWithRequestRevision:topLeft:topRight:bottomRight:bottomLeft:",
    );
late final _sel_topLeft = objc.registerName("topLeft");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_topRight = objc.registerName("topRight");
late final _sel_bottomLeft = objc.registerName("bottomLeft");
late final _sel_bottomRight = objc.registerName("bottomRight");

/// VNRectangleObservation
extension type VNRectangleObservation._(objc.ObjCObject object$)
    implements objc.ObjCObject, VNDetectedObjectObservation {
  /// Constructs a [VNRectangleObservation] that points to the same underlying object as [other].
  VNRectangleObservation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNRectangleObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNRectangleObservation] that wraps the given raw object pointer.
  VNRectangleObservation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNRectangleObservation',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNRectangleObservation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNRectangleObservation,
  );

  /// alloc
  static VNRectangleObservation alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNRectangleObservation,
      _sel_alloc,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static VNRectangleObservation allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNRectangleObservation,
      _sel_allocWithZone_,
      zone,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static VNRectangleObservation new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNRectangleObservation, _sel_new);
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// observationWithBoundingBox:
  static VNRectangleObservation observationWithBoundingBox(
    objc.CGRect boundingBox,
  ) {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.observationWithBoundingBox:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      _class_VNRectangleObservation,
      _sel_observationWithBoundingBox_,
      boundingBox,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// observationWithRequestRevision:boundingBox:
  static VNRectangleObservation observationWithRequestRevision(
    int requestRevision, {
    required objc.CGRect boundingBox,
  }) {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.observationWithRequestRevision:boundingBox:',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_1hw0xz7(
      _class_VNRectangleObservation,
      _sel_observationWithRequestRevision_boundingBox_,
      requestRevision,
      boundingBox,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// rectangleObservationWithRequestRevision:topLeft:bottomLeft:bottomRight:topRight:
  static VNRectangleObservation rectangleObservationWithRequestRevision(
    int requestRevision, {
    required objc.CGPoint topLeft,
    required objc.CGPoint bottomLeft,
    required objc.CGPoint bottomRight,
    required objc.CGPoint topRight,
  }) {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.rectangleObservationWithRequestRevision:topLeft:bottomLeft:bottomRight:topRight:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_22ka0q(
      _class_VNRectangleObservation,
      _sel_rectangleObservationWithRequestRevision_topLeft_bottomLeft_bottomRight_topRight_,
      requestRevision,
      topLeft,
      bottomLeft,
      bottomRight,
      topRight,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// rectangleObservationWithRequestRevision:topLeft:topRight:bottomRight:bottomLeft:
  static VNRectangleObservation rectangleObservationWithRequestRevision$1(
    int requestRevision, {
    required objc.CGPoint topLeft,
    required objc.CGPoint topRight,
    required objc.CGPoint bottomRight,
    required objc.CGPoint bottomLeft,
  }) {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.rectangleObservationWithRequestRevision:topLeft:topRight:bottomRight:bottomLeft:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_22ka0q(
      _class_VNRectangleObservation,
      _sel_rectangleObservationWithRequestRevision_topLeft_topRight_bottomRight_bottomLeft_,
      requestRevision,
      topLeft,
      topRight,
      bottomRight,
      bottomLeft,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_VNRectangleObservation,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of VNRectangleObservation constructed with the default `new` method.
  VNRectangleObservation() : this.as(new$().object$);
}

extension VNRectangleObservation$Methods on VNRectangleObservation {
  /// bottomLeft
  objc.CGPoint get bottomLeft {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.bottomLeft',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_bottomLeft)
        : $ptr.ref = _objc_msgSend_1uwdhlk(
            object$.ref.pointer,
            _sel_bottomLeft,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// bottomRight
  objc.CGPoint get bottomRight {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.bottomRight',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            $ptr,
            object$.ref.pointer,
            _sel_bottomRight,
          )
        : $ptr.ref = _objc_msgSend_1uwdhlk(
            object$.ref.pointer,
            _sel_bottomRight,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// init
  VNRectangleObservation init() {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNRectangleObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  VNRectangleObservation? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : VNRectangleObservation.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// topLeft
  objc.CGPoint get topLeft {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.topLeft',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_topLeft)
        : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_topLeft);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// topRight
  objc.CGPoint get topRight {
    objc.checkOsVersionInternal(
      'VNRectangleObservation.topRight',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_topRight)
        : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_topRight);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }
}

late final _class_VNRecognizedText = objc.getClass("VNRecognizedText");
late final _sel_string = objc.registerName("string");
late final _sel_boundingBoxForRange_error_ = objc.registerName(
  "boundingBoxForRange:error:",
);
final _objc_msgSend_1n0qtg6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();

/// VNRecognizedText
extension type VNRecognizedText._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding,
        VNRequestRevisionProviding {
  /// Constructs a [VNRecognizedText] that points to the same underlying object as [other].
  VNRecognizedText.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNRecognizedText',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNRecognizedText] that wraps the given raw object pointer.
  VNRecognizedText.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNRecognizedText',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNRecognizedText].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNRecognizedText,
  );

  /// alloc
  static VNRecognizedText alloc() {
    final $ret = _objc_msgSend_151sglz(_class_VNRecognizedText, _sel_alloc);
    return VNRecognizedText.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static VNRecognizedText allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNRecognizedText,
      _sel_allocWithZone_,
      zone,
    );
    return VNRecognizedText.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static VNRecognizedText new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNRecognizedText, _sel_new);
    return VNRecognizedText.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_VNRecognizedText,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of VNRecognizedText constructed with the default `new` method.
  VNRecognizedText() : this.as(new$().object$);
}

extension VNRecognizedText$Methods on VNRecognizedText {
  /// boundingBoxForRange:error:
  VNRectangleObservation? boundingBoxForRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'VNRecognizedText.boundingBoxForRange:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1n0qtg6(
        object$.ref.pointer,
        _sel_boundingBoxForRange_error_,
        range,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : VNRectangleObservation.fromPointer(
              $ret,
              retain: true,
              release: true,
            );
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// confidence
  double get confidence {
    objc.checkOsVersionInternal(
      'VNRecognizedText.confidence',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_confidence)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_confidence);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  VNRecognizedText init() {
    objc.checkOsVersionInternal(
      'VNRecognizedText.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNRecognizedText.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  VNRecognizedText? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : VNRecognizedText.fromPointer($ret, retain: false, release: true);
  }

  /// requestRevision
  int get requestRevision {
    objc.checkOsVersionInternal(
      'VNRecognizedText.requestRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_requestRevision);
  }

  /// string
  objc.NSString get string {
    objc.checkOsVersionInternal(
      'VNRecognizedText.string',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_string);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_VNRecognizedTextObservation = objc.getClass(
  "VNRecognizedTextObservation",
);
late final _sel_topCandidates_ = objc.registerName("topCandidates:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// VNRecognizedTextObservation
extension type VNRecognizedTextObservation._(objc.ObjCObject object$)
    implements objc.ObjCObject, VNRectangleObservation {
  /// Constructs a [VNRecognizedTextObservation] that points to the same underlying object as [other].
  VNRecognizedTextObservation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNRecognizedTextObservation] that wraps the given raw object pointer.
  VNRecognizedTextObservation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNRecognizedTextObservation].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNRecognizedTextObservation,
  );

  /// alloc
  static VNRecognizedTextObservation alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNRecognizedTextObservation,
      _sel_alloc,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static VNRecognizedTextObservation allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNRecognizedTextObservation,
      _sel_allocWithZone_,
      zone,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static VNRecognizedTextObservation new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNRecognizedTextObservation,
      _sel_new,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// observationWithBoundingBox:
  static VNRecognizedTextObservation observationWithBoundingBox(
    objc.CGRect boundingBox,
  ) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.observationWithBoundingBox:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      _class_VNRecognizedTextObservation,
      _sel_observationWithBoundingBox_,
      boundingBox,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// observationWithRequestRevision:boundingBox:
  static VNRecognizedTextObservation observationWithRequestRevision(
    int requestRevision, {
    required objc.CGRect boundingBox,
  }) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.observationWithRequestRevision:boundingBox:',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_1hw0xz7(
      _class_VNRecognizedTextObservation,
      _sel_observationWithRequestRevision_boundingBox_,
      requestRevision,
      boundingBox,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// rectangleObservationWithRequestRevision:topLeft:bottomLeft:bottomRight:topRight:
  static VNRecognizedTextObservation rectangleObservationWithRequestRevision(
    int requestRevision, {
    required objc.CGPoint topLeft,
    required objc.CGPoint bottomLeft,
    required objc.CGPoint bottomRight,
    required objc.CGPoint topRight,
  }) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.rectangleObservationWithRequestRevision:topLeft:bottomLeft:bottomRight:topRight:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_22ka0q(
      _class_VNRecognizedTextObservation,
      _sel_rectangleObservationWithRequestRevision_topLeft_bottomLeft_bottomRight_topRight_,
      requestRevision,
      topLeft,
      bottomLeft,
      bottomRight,
      topRight,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// rectangleObservationWithRequestRevision:topLeft:topRight:bottomRight:bottomLeft:
  static VNRecognizedTextObservation rectangleObservationWithRequestRevision$1(
    int requestRevision, {
    required objc.CGPoint topLeft,
    required objc.CGPoint topRight,
    required objc.CGPoint bottomRight,
    required objc.CGPoint bottomLeft,
  }) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.rectangleObservationWithRequestRevision:topLeft:topRight:bottomRight:bottomLeft:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_22ka0q(
      _class_VNRecognizedTextObservation,
      _sel_rectangleObservationWithRequestRevision_topLeft_topRight_bottomRight_bottomLeft_,
      requestRevision,
      topLeft,
      topRight,
      bottomRight,
      bottomLeft,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_VNRecognizedTextObservation,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of VNRecognizedTextObservation constructed with the default `new` method.
  VNRecognizedTextObservation() : this.as(new$().object$);
}

extension VNRecognizedTextObservation$Methods on VNRecognizedTextObservation {
  /// init
  VNRecognizedTextObservation init() {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNRecognizedTextObservation.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  VNRecognizedTextObservation? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : VNRecognizedTextObservation.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// topCandidates:
  objc.NSArray topCandidates(int maxCandidateCount) {
    objc.checkOsVersionInternal(
      'VNRecognizedTextObservation.topCandidates:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      object$.ref.pointer,
      _sel_topCandidates_,
      maxCandidateCount,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_VNRequest = objc.getClass("VNRequest");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_VNRequest_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>
  fromFunction(
    void Function(VNRequest, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)> listener(
    void Function(VNRequest, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)> blocking(
    void Function(VNRequest, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_VNRequest_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)> {
  void call(VNRequest arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_initWithCompletionHandler_ = objc.registerName(
  "initWithCompletionHandler:",
);
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_preferBackgroundProcessing = objc.registerName(
  "preferBackgroundProcessing",
);
late final _sel_setPreferBackgroundProcessing_ = objc.registerName(
  "setPreferBackgroundProcessing:",
);
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_usesCPUOnly = objc.registerName("usesCPUOnly");
late final _sel_setUsesCPUOnly_ = objc.registerName("setUsesCPUOnly:");
late final _sel_results = objc.registerName("results");
late final _sel_completionHandler = objc.registerName("completionHandler");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_revision = objc.registerName("revision");
late final _sel_setRevision_ = objc.registerName("setRevision:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_supportedRevisions = objc.registerName("supportedRevisions");
late final _sel_defaultRevision = objc.registerName("defaultRevision");
late final _sel_currentRevision = objc.registerName("currentRevision");
late final _sel_cancel = objc.registerName("cancel");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_supportedComputeStageDevicesAndReturnError_ = objc.registerName(
  "supportedComputeStageDevicesAndReturnError:",
);
final _objc_msgSend_1w05pgk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_computeDeviceForComputeStage_ = objc.registerName(
  "computeDeviceForComputeStage:",
);
late final _sel_setComputeDevice_forComputeStage_ = objc.registerName(
  "setComputeDevice:forComputeStage:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

///
extension unnamed on VNRequest {}

/// VNRequest
extension type VNRequest._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [VNRequest] that points to the same underlying object as [other].
  VNRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNRequest',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNRequest] that wraps the given raw object pointer.
  VNRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNRequest',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNRequest,
  );

  /// alloc
  static VNRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_VNRequest, _sel_alloc);
    return VNRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static VNRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNRequest,
      _sel_allocWithZone_,
      zone,
    );
    return VNRequest.fromPointer($ret, retain: false, release: true);
  }

  /// currentRevision
  static int getCurrentRevision() {
    objc.checkOsVersionInternal(
      'VNRequest.currentRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(_class_VNRequest, _sel_currentRevision);
  }

  /// defaultRevision
  static int getDefaultRevision() {
    objc.checkOsVersionInternal(
      'VNRequest.defaultRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(_class_VNRequest, _sel_defaultRevision);
  }

  /// new
  static VNRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNRequest, _sel_new);
    return VNRequest.fromPointer($ret, retain: false, release: true);
  }

  /// supportedRevisions
  static objc.NSIndexSet getSupportedRevisions() {
    objc.checkOsVersionInternal(
      'VNRequest.supportedRevisions',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_VNRequest,
      _sel_supportedRevisions,
    );
    return objc.NSIndexSet.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of VNRequest constructed with the default `new` method.
  VNRequest() : this.as(new$().object$);
}

extension VNRequest$Methods on VNRequest {
  /// cancel
  void cancel() {
    objc.checkOsVersionInternal(
      'VNRequest.cancel',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_cancel);
  }

  /// completionHandler
  objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>?
  get completionHandler {
    objc.checkOsVersionInternal(
      'VNRequest.completionHandler',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(
      object$.ref.pointer,
      _sel_completionHandler,
    );
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_VNRequest_NSError.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// computeDeviceForComputeStage:
  MLComputeDeviceProtocol? computeDeviceForComputeStage(
    objc.NSString computeStage,
  ) {
    objc.checkOsVersionInternal(
      'VNRequest.computeDeviceForComputeStage:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_computeDeviceForComputeStage_,
      computeStage.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : MLComputeDeviceProtocol.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// init
  VNRequest init() {
    objc.checkOsVersionInternal(
      'VNRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCompletionHandler:
  VNRequest initWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>?
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'VNRequest.initWithCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
    return VNRequest.fromPointer($ret, retain: false, release: true);
  }

  /// preferBackgroundProcessing
  bool get preferBackgroundProcessing {
    objc.checkOsVersionInternal(
      'VNRequest.preferBackgroundProcessing',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_preferBackgroundProcessing,
    );
  }

  /// results
  objc.NSArray? get results {
    objc.checkOsVersionInternal(
      'VNRequest.results',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_results);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// revision
  int get revision {
    objc.checkOsVersionInternal(
      'VNRequest.revision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_revision);
  }

  /// setComputeDevice:forComputeStage:
  void setComputeDevice(
    MLComputeDeviceProtocol? computeDevice, {
    required objc.NSString forComputeStage,
  }) {
    objc.checkOsVersionInternal(
      'VNRequest.setComputeDevice:forComputeStage:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setComputeDevice_forComputeStage_,
      computeDevice?.ref.pointer ?? ffi.nullptr,
      forComputeStage.ref.pointer,
    );
  }

  /// setPreferBackgroundProcessing:
  set preferBackgroundProcessing(bool value) {
    objc.checkOsVersionInternal(
      'VNRequest.setPreferBackgroundProcessing:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPreferBackgroundProcessing_,
      value,
    );
  }

  /// setRevision:
  set revision(int value) {
    objc.checkOsVersionInternal(
      'VNRequest.setRevision:',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    _objc_msgSend_1i9r4xy(object$.ref.pointer, _sel_setRevision_, value);
  }

  /// setUsesCPUOnly:
  set usesCPUOnly(bool value) {
    objc.checkOsVersionInternal(
      'VNRequest.setUsesCPUOnly:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setUsesCPUOnly_, value);
  }

  /// supportedComputeStageDevicesAndReturnError:
  objc.NSDictionary? supportedComputeStageDevicesAndReturnError() {
    objc.checkOsVersionInternal(
      'VNRequest.supportedComputeStageDevicesAndReturnError:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1w05pgk(
        object$.ref.pointer,
        _sel_supportedComputeStageDevicesAndReturnError_,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// usesCPUOnly
  bool get usesCPUOnly {
    objc.checkOsVersionInternal(
      'VNRequest.usesCPUOnly',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_usesCPUOnly);
  }
}

late final _class_VNImageBasedRequest = objc.getClass("VNImageBasedRequest");
late final _sel_regionOfInterest = objc.registerName("regionOfInterest");
late final _sel_setRegionOfInterest_ = objc.registerName(
  "setRegionOfInterest:",
);
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();

/// VNImageBasedRequest
extension type VNImageBasedRequest._(objc.ObjCObject object$)
    implements objc.ObjCObject, VNRequest {
  /// Constructs a [VNImageBasedRequest] that points to the same underlying object as [other].
  VNImageBasedRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNImageBasedRequest] that wraps the given raw object pointer.
  VNImageBasedRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNImageBasedRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNImageBasedRequest,
  );

  /// alloc
  static VNImageBasedRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_VNImageBasedRequest, _sel_alloc);
    return VNImageBasedRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static VNImageBasedRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNImageBasedRequest,
      _sel_allocWithZone_,
      zone,
    );
    return VNImageBasedRequest.fromPointer($ret, retain: false, release: true);
  }

  /// currentRevision
  static int getCurrentRevision() {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.currentRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(
      _class_VNImageBasedRequest,
      _sel_currentRevision,
    );
  }

  /// defaultRevision
  static int getDefaultRevision() {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.defaultRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(
      _class_VNImageBasedRequest,
      _sel_defaultRevision,
    );
  }

  /// new
  static VNImageBasedRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNImageBasedRequest, _sel_new);
    return VNImageBasedRequest.fromPointer($ret, retain: false, release: true);
  }

  /// supportedRevisions
  static objc.NSIndexSet getSupportedRevisions() {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.supportedRevisions',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_VNImageBasedRequest,
      _sel_supportedRevisions,
    );
    return objc.NSIndexSet.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of VNImageBasedRequest constructed with the default `new` method.
  VNImageBasedRequest() : this.as(new$().object$);
}

extension VNImageBasedRequest$Methods on VNImageBasedRequest {
  /// init
  VNImageBasedRequest init() {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNImageBasedRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCompletionHandler:
  VNImageBasedRequest initWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>?
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.initWithCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
    return VNImageBasedRequest.fromPointer($ret, retain: false, release: true);
  }

  /// regionOfInterest
  objc.CGRect get regionOfInterest {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.regionOfInterest',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_regionOfInterest,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_regionOfInterest,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// setRegionOfInterest:
  set regionOfInterest(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'VNImageBasedRequest.setRegionOfInterest:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setRegionOfInterest_,
      value,
    );
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Double arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  fromFunction(
    void Function(VNRequest, double, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        double arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: true, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  listener(
    void Function(VNRequest, double, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        double arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_r1s65y(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  blocking(
    void Function(VNRequest, double, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        double arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        double arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        VNRequest.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_r1s65y(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    double arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          double,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    double arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            double,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    double arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Double arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          double,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Double,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    double arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            double,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Double,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)> {
  void call(VNRequest arg0, double arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Double arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              double,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0.ref.pointer,
        arg1,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

/// WARNING: VNRequestProgressProviding is a stub. To generate bindings for this class, include
/// VNRequestProgressProviding in your config's objc-protocols list.
///
/// VNRequestProgressProviding
extension type VNRequestProgressProviding._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [VNRequestProgressProviding] that points to the same underlying object as [other].
  VNRequestProgressProviding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [VNRequestProgressProviding] that wraps the given raw object pointer.
  VNRequestProgressProviding.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum VNRequestTextRecognitionLevel {
  VNRequestTextRecognitionLevelAccurate(0),
  VNRequestTextRecognitionLevelFast(1);

  final int value;
  const VNRequestTextRecognitionLevel(this.value);

  static VNRequestTextRecognitionLevel fromValue(int value) => switch (value) {
    0 => VNRequestTextRecognitionLevelAccurate,
    1 => VNRequestTextRecognitionLevelFast,
    _ => throw ArgumentError(
      'Unknown value for VNRequestTextRecognitionLevel: $value',
    ),
  };
}

late final _class_VNRecognizeTextRequest = objc.getClass(
  "VNRecognizeTextRequest",
);
late final _sel_supportedRecognitionLanguagesForTextRecognitionLevel_revision_error_ =
    objc.registerName(
      "supportedRecognitionLanguagesForTextRecognitionLevel:revision:error:",
    );
final _objc_msgSend_15mybp4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_supportedRecognitionLanguagesAndReturnError_ = objc
    .registerName("supportedRecognitionLanguagesAndReturnError:");
late final _sel_recognitionLanguages = objc.registerName(
  "recognitionLanguages",
);
late final _sel_setRecognitionLanguages_ = objc.registerName(
  "setRecognitionLanguages:",
);
late final _sel_customWords = objc.registerName("customWords");
late final _sel_setCustomWords_ = objc.registerName("setCustomWords:");
late final _sel_recognitionLevel = objc.registerName("recognitionLevel");
final _objc_msgSend_pv4ily = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setRecognitionLevel_ = objc.registerName(
  "setRecognitionLevel:",
);
final _objc_msgSend_1vuy63o = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_usesLanguageCorrection = objc.registerName(
  "usesLanguageCorrection",
);
late final _sel_setUsesLanguageCorrection_ = objc.registerName(
  "setUsesLanguageCorrection:",
);
late final _sel_automaticallyDetectsLanguage = objc.registerName(
  "automaticallyDetectsLanguage",
);
late final _sel_setAutomaticallyDetectsLanguage_ = objc.registerName(
  "setAutomaticallyDetectsLanguage:",
);
late final _sel_minimumTextHeight = objc.registerName("minimumTextHeight");
late final _sel_setMinimumTextHeight_ = objc.registerName(
  "setMinimumTextHeight:",
);
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_progressHandler = objc.registerName("progressHandler");

/// Construction methods for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_VNRequestProgressHandler_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
        Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
        Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    Function(ffi.Pointer<ffi.Void>)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
        Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCBlockImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCBlockImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_VNRequestProgressHandler_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          objc.ObjCBlock<
            ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
          >
          Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)> call(
    ffi.Pointer<ffi.Void> arg0,
  ) => ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_setProgressHandler_ = objc.registerName("setProgressHandler:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>
  fromFunction(
    void Function(objc.ObjCBlock<ffi.Void Function()>?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCBlockImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : ObjCBlock_ffiVoid.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>
  listener(
    void Function(objc.ObjCBlock<ffi.Void Function()>?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCBlockImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : ObjCBlock_ffiVoid.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_f167m6(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>
  blocking(
    void Function(objc.ObjCBlock<ffi.Void Function()>?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCBlockImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : ObjCBlock_ffiVoid.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCBlockImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : ObjCBlock_ffiVoid.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_f167m6(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCBlockImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCBlockImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCBlockImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid$1$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function()>?)> {
  void call(objc.ObjCBlock<ffi.Void Function()>? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_VNRequestProgressHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<
            ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
          >,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCBlockImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<
            ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
          >,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<
            ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
          >,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
              fn(
                arg0,
                ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1l4hxwm(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_VNRequestProgressHandler$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            objc.ObjCBlock<
              ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)
            >,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    arg1,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_indeterminate = objc.registerName("indeterminate");

/// VNRecognizeTextRequest
extension type VNRecognizeTextRequest._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        VNImageBasedRequest,
        VNRequestProgressProviding {
  /// Constructs a [VNRecognizeTextRequest] that points to the same underlying object as [other].
  VNRecognizeTextRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNRecognizeTextRequest] that wraps the given raw object pointer.
  VNRecognizeTextRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNRecognizeTextRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNRecognizeTextRequest,
  );

  /// alloc
  static VNRecognizeTextRequest alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNRecognizeTextRequest,
      _sel_alloc,
    );
    return VNRecognizeTextRequest.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static VNRecognizeTextRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNRecognizeTextRequest,
      _sel_allocWithZone_,
      zone,
    );
    return VNRecognizeTextRequest.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// currentRevision
  static int getCurrentRevision() {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.currentRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(
      _class_VNRecognizeTextRequest,
      _sel_currentRevision,
    );
  }

  /// defaultRevision
  static int getDefaultRevision() {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.defaultRevision',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    return _objc_msgSend_xw2lbc(
      _class_VNRecognizeTextRequest,
      _sel_defaultRevision,
    );
  }

  /// new
  static VNRecognizeTextRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNRecognizeTextRequest, _sel_new);
    return VNRecognizeTextRequest.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportedRecognitionLanguagesForTextRecognitionLevel:revision:error:
  static objc.NSArray? supportedRecognitionLanguagesForTextRecognitionLevel(
    VNRequestTextRecognitionLevel recognitionLevel, {
    required int revision,
  }) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.supportedRecognitionLanguagesForTextRecognitionLevel:revision:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_15mybp4(
        _class_VNRecognizeTextRequest,
        _sel_supportedRecognitionLanguagesForTextRecognitionLevel_revision_error_,
        recognitionLevel.value,
        revision,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSArray.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// supportedRevisions
  static objc.NSIndexSet getSupportedRevisions() {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.supportedRevisions',
      iOS: (false, (12, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_VNRecognizeTextRequest,
      _sel_supportedRevisions,
    );
    return objc.NSIndexSet.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of VNRecognizeTextRequest constructed with the default `new` method.
  VNRecognizeTextRequest() : this.as(new$().object$);
}

extension VNRecognizeTextRequest$Methods on VNRecognizeTextRequest {
  /// automaticallyDetectsLanguage
  bool get automaticallyDetectsLanguage {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.automaticallyDetectsLanguage',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_automaticallyDetectsLanguage,
    );
  }

  /// customWords
  objc.NSArray get customWords {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.customWords',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_customWords);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// indeterminate
  bool get indeterminate {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.indeterminate',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_indeterminate);
  }

  /// init
  VNRecognizeTextRequest init() {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNRecognizeTextRequest.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCompletionHandler:
  VNRecognizeTextRequest initWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(VNRequest, objc.NSError?)>?
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.initWithCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
    return VNRecognizeTextRequest.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// minimumTextHeight
  double get minimumTextHeight {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.minimumTextHeight',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_minimumTextHeight)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_minimumTextHeight);
  }

  /// progressHandler
  objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
  get progressHandler {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.progressHandler',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(
      object$.ref.pointer,
      _sel_progressHandler,
    );
    return ObjCBlock_ffiVoid_VNRequest_ffiDouble_NSError.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// recognitionLanguages
  objc.NSArray get recognitionLanguages {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.recognitionLanguages',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_recognitionLanguages,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// recognitionLevel
  VNRequestTextRecognitionLevel get recognitionLevel {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.recognitionLevel',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_pv4ily(
      object$.ref.pointer,
      _sel_recognitionLevel,
    );
    return VNRequestTextRecognitionLevel.fromValue($ret);
  }

  /// results
  objc.NSArray? get results {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.results',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_results);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// setAutomaticallyDetectsLanguage:
  set automaticallyDetectsLanguage(bool value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setAutomaticallyDetectsLanguage:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutomaticallyDetectsLanguage_,
      value,
    );
  }

  /// setCustomWords:
  set customWords(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setCustomWords:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCustomWords_,
      value.ref.pointer,
    );
  }

  /// setMinimumTextHeight:
  set minimumTextHeight(double value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setMinimumTextHeight:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_v5hmet(
      object$.ref.pointer,
      _sel_setMinimumTextHeight_,
      value,
    );
  }

  /// setProgressHandler:
  set progressHandler(
    objc.ObjCBlock<ffi.Void Function(VNRequest, ffi.Double, objc.NSError?)>
    value,
  ) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setProgressHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_setProgressHandler_,
      value.ref.pointer,
    );
  }

  /// setRecognitionLanguages:
  set recognitionLanguages(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setRecognitionLanguages:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setRecognitionLanguages_,
      value.ref.pointer,
    );
  }

  /// setRecognitionLevel:
  set recognitionLevel(VNRequestTextRecognitionLevel value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setRecognitionLevel:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1vuy63o(
      object$.ref.pointer,
      _sel_setRecognitionLevel_,
      value.value,
    );
  }

  /// setUsesLanguageCorrection:
  set usesLanguageCorrection(bool value) {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.setUsesLanguageCorrection:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUsesLanguageCorrection_,
      value,
    );
  }

  /// supportedRecognitionLanguagesAndReturnError:
  objc.NSArray? supportedRecognitionLanguagesAndReturnError() {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.supportedRecognitionLanguagesAndReturnError:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1w05pgk(
        object$.ref.pointer,
        _sel_supportedRecognitionLanguagesAndReturnError_,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0
          ? null
          : objc.NSArray.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// usesLanguageCorrection
  bool get usesLanguageCorrection {
    objc.checkOsVersionInternal(
      'VNRecognizeTextRequest.usesLanguageCorrection',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_usesLanguageCorrection,
    );
  }
}

late final _class_VNImageRequestHandler = objc.getClass(
  "VNImageRequestHandler",
);
late final _sel_initWithCVPixelBuffer_options_ = objc.registerName(
  "initWithCVPixelBuffer:options:",
);
final _objc_msgSend_vhfhux = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<__CVBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<__CVBuffer>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCVPixelBuffer_orientation_options_ = objc.registerName(
  "initWithCVPixelBuffer:orientation:options:",
);
final _objc_msgSend_gsfdtd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<__CVBuffer>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<__CVBuffer>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// WARNING: AVDepthData is a stub. To generate bindings for this class, include
/// AVDepthData in your config's objc-interfaces list.
///
/// AVDepthData
extension type AVDepthData._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [AVDepthData] that points to the same underlying object as [other].
  AVDepthData.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [AVDepthData] that wraps the given raw object pointer.
  AVDepthData.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_initWithCVPixelBuffer_depthData_orientation_options_ = objc
    .registerName("initWithCVPixelBuffer:depthData:orientation:options:");
final _objc_msgSend_182e0nn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<__CVBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<__CVBuffer>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCGImage_options_ = objc.registerName(
  "initWithCGImage:options:",
);
final _objc_msgSend_vew1en = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGImage>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGImage>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCGImage_orientation_options_ = objc.registerName(
  "initWithCGImage:orientation:options:",
);
final _objc_msgSend_14t5g83 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGImage>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGImage>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// WARNING: CIImage is a stub. To generate bindings for this class, include
/// CIImage in your config's objc-interfaces list.
///
/// CIImage
extension type CIImage._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [CIImage] that points to the same underlying object as [other].
  CIImage.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [CIImage] that wraps the given raw object pointer.
  CIImage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_initWithCIImage_options_ = objc.registerName(
  "initWithCIImage:options:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCIImage_orientation_options_ = objc.registerName(
  "initWithCIImage:orientation:options:",
);
final _objc_msgSend_1ww1e99 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithURL_options_ = objc.registerName(
  "initWithURL:options:",
);
late final _sel_initWithURL_orientation_options_ = objc.registerName(
  "initWithURL:orientation:options:",
);
late final _sel_initWithData_options_ = objc.registerName(
  "initWithData:options:",
);
late final _sel_initWithData_orientation_options_ = objc.registerName(
  "initWithData:orientation:options:",
);
late final _sel_initWithCMSampleBuffer_options_ = objc.registerName(
  "initWithCMSampleBuffer:options:",
);
final _objc_msgSend_1u2oz67 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<opaqueCMSampleBuffer>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCMSampleBuffer_orientation_options_ = objc.registerName(
  "initWithCMSampleBuffer:orientation:options:",
);
final _objc_msgSend_2tsvw3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<opaqueCMSampleBuffer>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithCMSampleBuffer_depthData_orientation_options_ = objc
    .registerName("initWithCMSampleBuffer:depthData:orientation:options:");
final _objc_msgSend_18zbzgl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<opaqueCMSampleBuffer>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Uint32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<opaqueCMSampleBuffer>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_performRequests_error_ = objc.registerName(
  "performRequests:error:",
);
final _objc_msgSend_l9p60w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();

/// VNImageRequestHandler
extension type VNImageRequestHandler._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [VNImageRequestHandler] that points to the same underlying object as [other].
  VNImageRequestHandler.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [VNImageRequestHandler] that wraps the given raw object pointer.
  VNImageRequestHandler.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [VNImageRequestHandler].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_VNImageRequestHandler,
  );

  /// alloc
  static VNImageRequestHandler alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_VNImageRequestHandler,
      _sel_alloc,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static VNImageRequestHandler allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_VNImageRequestHandler,
      _sel_allocWithZone_,
      zone,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static VNImageRequestHandler new$() {
    final $ret = _objc_msgSend_151sglz(_class_VNImageRequestHandler, _sel_new);
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of VNImageRequestHandler constructed with the default `new` method.
  VNImageRequestHandler() : this.as(new$().object$);
}

extension VNImageRequestHandler$Methods on VNImageRequestHandler {
  /// init
  VNImageRequestHandler init() {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCGImage:options:
  VNImageRequestHandler initWithCGImage(
    ffi.Pointer<CGImage> image, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCGImage:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_vew1en(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCGImage_options_,
      image,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCGImage:orientation:options:
  VNImageRequestHandler initWithCGImage$1(
    ffi.Pointer<CGImage> image, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCGImage:orientation:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_14t5g83(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCGImage_orientation_options_,
      image,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCIImage:options:
  VNImageRequestHandler initWithCIImage(
    CIImage image, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCIImage:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCIImage_options_,
      image.ref.pointer,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCIImage:orientation:options:
  VNImageRequestHandler initWithCIImage$1(
    CIImage image, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCIImage:orientation:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1ww1e99(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCIImage_orientation_options_,
      image.ref.pointer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCMSampleBuffer:depthData:orientation:options:
  VNImageRequestHandler initWithCMSampleBuffer(
    ffi.Pointer<opaqueCMSampleBuffer> sampleBuffer, {
    required AVDepthData depthData,
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCMSampleBuffer:depthData:orientation:options:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_18zbzgl(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCMSampleBuffer_depthData_orientation_options_,
      sampleBuffer,
      depthData.ref.pointer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCMSampleBuffer:options:
  VNImageRequestHandler initWithCMSampleBuffer$1(
    ffi.Pointer<opaqueCMSampleBuffer> sampleBuffer, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCMSampleBuffer:options:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1u2oz67(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCMSampleBuffer_options_,
      sampleBuffer,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCMSampleBuffer:orientation:options:
  VNImageRequestHandler initWithCMSampleBuffer$2(
    ffi.Pointer<opaqueCMSampleBuffer> sampleBuffer, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCMSampleBuffer:orientation:options:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_2tsvw3(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCMSampleBuffer_orientation_options_,
      sampleBuffer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCVPixelBuffer:depthData:orientation:options:
  VNImageRequestHandler initWithCVPixelBuffer(
    ffi.Pointer<__CVBuffer> pixelBuffer, {
    required AVDepthData depthData,
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCVPixelBuffer:depthData:orientation:options:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_182e0nn(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCVPixelBuffer_depthData_orientation_options_,
      pixelBuffer,
      depthData.ref.pointer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCVPixelBuffer:options:
  VNImageRequestHandler initWithCVPixelBuffer$1(
    ffi.Pointer<__CVBuffer> pixelBuffer, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCVPixelBuffer:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_vhfhux(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCVPixelBuffer_options_,
      pixelBuffer,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCVPixelBuffer:orientation:options:
  VNImageRequestHandler initWithCVPixelBuffer$2(
    ffi.Pointer<__CVBuffer> pixelBuffer, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithCVPixelBuffer:orientation:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_gsfdtd(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCVPixelBuffer_orientation_options_,
      pixelBuffer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithData:options:
  VNImageRequestHandler initWithData(
    objc.NSData imageData, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithData:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithData_options_,
      imageData.ref.pointer,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithData:orientation:options:
  VNImageRequestHandler initWithData$1(
    objc.NSData imageData, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithData:orientation:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1ww1e99(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithData_orientation_options_,
      imageData.ref.pointer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithURL:options:
  VNImageRequestHandler initWithURL(
    objc.NSURL imageURL, {
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithURL:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_options_,
      imageURL.ref.pointer,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithURL:orientation:options:
  VNImageRequestHandler initWithURL$1(
    objc.NSURL imageURL, {
    required CGImagePropertyOrientation orientation,
    required objc.NSDictionary options,
  }) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.initWithURL:orientation:options:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1ww1e99(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_orientation_options_,
      imageURL.ref.pointer,
      orientation.value,
      options.ref.pointer,
    );
    return VNImageRequestHandler.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// performRequests:error:
  bool performRequests(objc.NSArray requests) {
    objc.checkOsVersionInternal(
      'VNImageRequestHandler.performRequests:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_l9p60w(
        object$.ref.pointer,
        _sel_performRequests_error_,
        requests.ref.pointer,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret;
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }
}
